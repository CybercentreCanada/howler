{
  "basic": "Basic Search",
  "basic.ex1": "\"quick brown fox\"",
  "basic.ex2": "quick OR brown OR fox",
  "basic.text": "The search query is parsed into a series of terms and operators. A term can be a single word like quick, brown or a phrase, surrounded by double quotes \"quick brown\" which searches for all the words in the phrase, in the same order.",
  "exemples": "Examples:",
  "fields": "Fields",
  "fields.att.default": "default",
  "fields.att.list": "list",
  "fields.att.stored": "stored",
  "fields.ex1": "status:active",
  "fields.ex1.title": "where the status field contains active",
  "fields.ex2": "title:(quick OR brown)",
  "fields.ex2.title": "where the title field contains quick or brown",
  "fields.ex3": "author:\"John Smith\"",
  "fields.ex3.title": "where the author field contains the exact phrase \"john smith\"",
  "fields.ex4": "book.\\*:(quick OR brown)",
  "fields.ex4.title": "where any of the fields book.title, book.content or book.date contains quick or brown (note how we need to escape the * with a backslash):",
  "fields.ex5": "_exists_:title",
  "fields.ex5.title": "where the field title has any non-null value:",

  "fields.idx_hit": "Hit index",
  "fields.idx_user": "User index",
  "fields.idx_template": "Template index",
  "fields.idx_analytic": "Analytic index",
  "fields.idx_action": "Action index",
  "fields.idx_view": "View index",

  "fields.important": "Important",
  "fields.important.text": "When using the search engine in the UI, your search query is performed on all these indexes at the same time unless you explicitly specify which index you want to target.",
  "fields.legend": "Legend",
  "fields.legend.default": "Queried when no fields are specified",
  "fields.legend.ip_field": "Can be queried using CIDR notation",
  "fields.legend.list": "Can have multiple values in the same document",
  "fields.legend.stored": "Returned by default in search results",
  "fields.legend.text": "The special particularities of some field types as well as their various attributes are explained here:",
  "fields.legend.text_field": "Only the first 4k is indexed, wildcard searches will not work as expected and this field cannot be sorted",
  "fields.table.attrib": "Attributes",
  "fields.table.description": "Description",
  "fields.table.name": "Field name",
  "fields.table.type": "Type",
  "fields.text": "By using basic search, only the default field is searched for the search terms, but it is possible to specify other fields in the query syntax:",
  "fields.text2": "The Howler datastore is divided in multiple indexes. Each index has the following fields available for searches. Default fields are copied over to the default search field that is used in the case where you only use basic search. Stored field will be returned by the index when issuing a query.",
  "fuzziness": "Fuzziness",
  "fuzziness.ex": "quikc~ brwn~ foks~",
  "fuzziness.ex2": "quikc~1",
  "fuzziness.text": "We can search for terms that are similar to, but not exactly like our search terms, using the “fuzzy” operator:\n",
  "fuzziness.text2": "This uses the Damerau-Levenshtein distance to find all terms with a maximum of two changes, where a change is the insertion, deletion or substitution of a single character, or transposition of two adjacent characters.",
  "fuzziness.text3": "The default edit distance is 2, but an edit distance of 1 should be sufficient to catch 80% of all human misspellings. It can be specified as:",
  "grouping": "Grouping",
  "grouping.ex": "(quick OR brown) AND fox",
  "grouping.ex2": "status:(active OR pending) title:(+full -\"text search\")",
  "grouping.text": "Multiple terms or clauses can be grouped together with parentheses, to form sub-queries:",
  "grouping.text2": "Groups can also be used to target a particular field:",
  "operator": "Boolean Operators",
  "operator.ex1": "quick brown +fox -news",
  "operator.ex2": "((quick AND fox) OR (brown AND fox) OR fox) AND NOT news",
  "operator.list1": "fox must be present",
  "operator.list2": "news must not be present",
  "operator.list3": "quick and brown are optional — their presence increases the relevance",
  "operator.text": "By default, all terms are optional, as long as one term matches. A search for foo bar baz will find any document that contains one or more of foo or bar or baz. We have already discussed the default_operator above which allows you to force all terms to be required, but there are also boolean operators which can be used in the search query itself to provide more control.",
  "operator.text2": "The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query:",
  "operator.text3": "states that:",
  "operator.text4": "The familiar boolean operators AND, OR and NOT (also written &&, || and !) are also supported but beware that they do not honor the usual precedence rules, so parentheses should be used whenever multiple operators are used together. For instance the previous query could be rewritten as:",
  "operator.text5": "This form now replicates the logic from the original query correctly, but the relevance scoring bears little resemblance to the original.",
  "overview": "Overview",
  "overview.text": "The search query “mini-language” is used by the Search API. Operators allow you to customize the search -- the available options are explained below:",
  "proximity": "Proximity Searches",
  "proximity.ex": "\"quick fox\"~5",
  "proximity.text": "While a phrase query (eg \"john smith\") expects all of the terms in exactly the same order, a proximity query allows the specified words to be further apart or in a different order. In the same way that fuzzy queries can specify a maximum edit distance for characters in a word, a proximity search allows us to specify a maximum edit distance of words in a phrase:",
  "proximity.text2": "The closer the text in a field is to the original order specified in the search query, the more relevant that document is considered to be. When compared to the above example query, the phrase \"quick fox\" would be considered more relevant than \"quick brown fox\".",
  "ranges": "Ranges",
  "ranges.datemath": "DateMath Syntax",
  "ranges.datemath.ex1": "y    =>    Years\nM    =>    Months\nw    =>    Weeks\nd    =>    Days\nh    =>    Hours\nH    =>    Hours\nm    =>    Minutes\ns    =>    Seconds",
  "ranges.datemath.ex2": "now+1h             =>  now in milliseconds plus one hour. Resolves to: 2001-01-01 13:00:00\nnow-1h             =>  now in milliseconds minus one hour. Resolves to: 2001-01-01 11:00:00\nnow-1h/d           =>  now in milliseconds minus one hour, rounded by day. Resolves to: 2001-01-01 00:00:00\n2001.02.01||+1M/d  =>  2001-02-01 in milliseconds plus one month rounded by day. Resolves to: 2001-03-01 00:00:00",
  "ranges.datemath.list1": "+1h: Add one hour",
  "ranges.datemath.list2": "-1d: Subtracts one day",
  "ranges.datemath.list3": "/d: Rounds down to the nearest day",
  "ranges.datemath.text": "The expression starts with an anchor date, which can either be now, or a date string ending with ||. This anchor date can optionally be followed by one or more maths expressions:",
  "ranges.datemath.text2": "The supported time units differ from those supported by time units for durations. The supported units are:",
  "ranges.datemath.text3": "Assuming now is 2001-01-01 12:00:00, here are some examples:",
  "ranges.ex1": "date:[2012-01-01 TO 2012-12-31]",
  "ranges.ex1.title": "All days in 2012:",
  "ranges.ex10": "age:(>=10 AND <20)\nage:(+>=10 +<20)",
  "ranges.ex2": "date:[now/y TO now/y+1y]",
  "ranges.ex2.title": "Everything this year: (Using DateMath syntax)",
  "ranges.ex3": "date:[2012-06-08||/y TO now]",
  "ranges.ex3.title": "Everything since the year of specific date: (Using DateMath syntax)",
  "ranges.ex4": "count:[1 TO 5]",
  "ranges.ex4.title": "Numbers 1..5",
  "ranges.ex5": "tag:{alpha TO omega}",
  "ranges.ex5.title": "Tags between alpha and omega, excluding alpha and omega:",
  "ranges.ex6": "count:[10 TO *]",
  "ranges.ex6.title": "Numbers from 10 upwards",
  "ranges.ex7": "date:{* TO 2012-01-01}",
  "ranges.ex7.title": "Dates before 2012",
  "ranges.ex8": "count:[1 TO 5}",
  "ranges.ex8.title": "Numbers from 1 up to but not including 5",
  "ranges.ex9": "age:>10\nage:>=10\nage:<10\nage:<=10",
  "ranges.text": "Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets [min TO max] and exclusive ranges with curly brackets {min TO max}.",
  "ranges.text2": "Curly and square brackets can be combined:",
  "ranges.text3": "Ranges with one side unbounded can use the following syntax:",
  "ranges.text4": "To combine an upper and lower bound with the simplified syntax, you would need to join two clauses with an AND operator:",
  "regex": "Regular Expressions",
  "regex.alternation": "Alternation",
  "regex.alternation.ex": "aabb|bbaa   # match\naacc|bb     # no match\naa(cc|bb)   # match\na+|b+       # no match\na+b+|b+a+   # match\na+(b|c)+    # match",
  "regex.alternation.text": "The pipe symbol \"|\" acts as an OR operator. The match will succeed if the pattern on either the left-hand side OR the right-hand side matches. The alternation applies to the longest pattern, not the shortest. For string \"aabb\":",
  "regex.anchoring": "Anchoring",
  "regex.anchoring.ex": "ab.*     # match\nabcd     # no match",
  "regex.anchoring.text": "Most regular expression engines allow you to match any part of a string. If you want the regexp pattern to start at the beginning of the string or finish at the end of the string, then you have to anchor it specifically, using ^ to indicate the beginning or $ to indicate the end.",
  "regex.anchoring.text2": "Lucene’s patterns are always anchored. The pattern provided must match the entire string. For string \"abcde\":",
  "regex.any": "Match Any",
  "regex.any.ex": "ab...   # match\na.c.e   # match",
  "regex.any.text": "The period \".\" can be used to represent any character. For string \"abcde\":",
  "regex.chars": "Allowed Characters",
  "regex.chars.ex": ". ? + * | { } [ ] ( ) \" \\",
  "regex.chars.ex2": "john\"@smith.com\"",
  "regex.chars.text": "Any Unicode characters may be used in the pattern, but certain characters are reserved and must be escaped. The standard reserved characters are:",
  "regex.chars.text2": "Any reserved character can be escaped with a backslash \"\\*\" including a literal backslash character: \"\\\\\"",
  "regex.chars.text3": "Additionally, any characters (except double quotes) are interpreted literally when surrounded by double quotes:",
  "regex.class": "Characters Class",
  "regex.class.ex": "[abc]   # 'a' or 'b' or 'c'\n[a-c]   # 'a' or 'b' or 'c'\n[-abc]  # '-' or 'a' or 'b' or 'c'\n[abc\\-] # '-' or 'a' or 'b' or 'c'\n[^abc]  # any character except 'a' or 'b' or 'c'\n[^a-c]  # any character except 'a' or 'b' or 'c'\n[^-abc]  # any character except '-' or 'a' or 'b' or 'c'\n[^abc\\-] # any character except '-' or 'a' or 'b' or 'c'",
  "regex.class.ex2": "ab[cd]+     # match\n[a-d]+      # match\n[^a-d]+     # no match",
  "regex.class.text": "Ranges of potential characters may be represented as character classes by enclosing them in square brackets \"[]\". A leading ^ negates the character class. The allowed forms are:\n",
  "regex.class.text2": "Note that the dash \"-\" indicates a range of characters, unless it is the first character or if it is escaped with a backslash.",
  "regex.class.text3": "For string \"abcd\":",
  "regex.ex": "name:/joh?n(ath[oa]n)/",
  "regex.grouping": "Grouping",
  "regex.grouping.ex": "(ab)+       # match\nab(ab)+     # match\n(..)+       # match\n(...)+      # no match\n(ab)*       # match\nabab(ab)?   # match\nab(ab)?     # no match\n(ab){3}     # match\n(ab){1,2}   # no match",
  "regex.grouping.text": "Parentheses \"()\" can be used to form sub-patterns. The quantity operators listed above operate on the shortest previous pattern, which can be a group. For string \"ababab\":",
  "regex.minmax": "Min to Max",
  "regex.minmax.ex": "{5}     # repeat exactly 5 times\n{2,5}   # repeat at least twice and at most 5 times\n{2,}    # repeat at least twice",
  "regex.minmax.ex2": "a{3}b{3}        # match\na{2,4}b{2,4}    # match\na{2,}b{2,}      # match\n.{3}.{3}        # match\na{4}b{4}        # no match\na{4,6}b{4,6}    # no match\na{4,}b{4,}      # no match",
  "regex.minmax.text": "Curly brackets \"{}\" can be used to specify a minimum and (optionally) a maximum number of times the preceding shortest pattern can repeat. The allowed forms are:",
  "regex.minmax.text2": "For string \"aaabbb\":",
  "regex.oneplus": "One or More",
  "regex.oneplus.ex": "a+b+        # match\naa+bb+      # match\na+.+        # match\naa+bbb+     # match",
  "regex.oneplus.text": "The plus sign \"+\" can be used to repeat the preceding shortest pattern once or more times. For string \"aaabbb\":",
  "regex.text": "Regular expression patterns can be embedded in the search query by wrapping them in forward-slashes (\"/\"):",
  "regex.warning": "Warning",
  "regex.warning.ex": "/.*n/",
  "regex.warning.follow": "The supported regular expression syntax is the following:",
  "regex.warning.text": "Having a wildcard as the leading parameter does not have any control over regular expressions. A search query such as the following would force the datastore to visit every term in the index, Use with caution!:",
  "regex.zeroone": "Zero or One",
  "regex.zeroone.ex": "aaa?bbb?    # match\naaaa?bbbb?  # match\n.....?.?    # match\naa?bb?      # no match",
  "regex.zeroone.text": "The question mark \"?\" makes the preceding shortest pattern optional. It matches zero or one times. For string \"aaabbb\":",
  "regex.zeroplus": "Zero or More",
  "regex.zeroplus.ex": "a*b*        # match\na*b*c*      # match\n.*bbb.*     # match\naaa*bbb*    # match",
  "regex.zeroplus.text": "The asterisk \"*\" can be used to match the preceding shortest pattern zero-or-more times. For string \"aaabbb\":",
  "reserved": "Reserved Characters",
  "reserved.ex": "\\(1\\+1\\)\\=2",
  "reserved.ex2": "+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /",
  "reserved.note": "Note",
  "reserved.text": "If you need to use any of the characters which function as operator's in your query itself (and not as operators), then you should escape them with a leading backslash.",
  "reserved.text2": "For instance, to search for (1+1)=2, you would need to write your query as:",
  "reserved.text3": "The reserved characters are:",
  "reserved.text4": "Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.",
  "reserved.text5": "< and > can’t be escaped at all. The only way to prevent them from attempting to create a range query is to remove them from the search query entirely.",
  "subtitle": "Lucene query syntax and index field list",
  "title": "Search help",
  "toc": "Contents",
  "top": "Back to top",
  "wildcard": "Wildcards",
  "wildcard.ex": "qu?ck bro*",
  "wildcard.note": "Note",
  "wildcard.note.text": "Allowing a wildcard at the beginning of a word (eg \"*ing\") is particularly heavy, because all terms in the index need to be examined, just in case they match.",
  "wildcard.text": "Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters:",
  "wildcard.text2": "Be aware that wildcard queries can use an enormous amount of memory and are very slow — just think how many terms need to be queried to match the search query \"a* b* c*\"."
}
