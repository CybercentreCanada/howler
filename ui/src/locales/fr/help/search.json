{
  "basic": "Recherche de base",
  "basic.ex1": "\"quick brown fox\"",
  "basic.ex2": "quick OR brown OR fox",
  "basic.text": "La requête de recherche est analysée en une série de termes et d'opérateurs. Un terme peut être un seul mot comme quick, brown ou une phrase, entouré de guillemets doubles \"quick brown\" qui recherche tous les mots de la phrase, dans le même ordre.",
  "exemples": "Exemples:",
  "fields": "Champs",
  "fields.att.default": "défaut",
  "fields.att.list": "liste",
  "fields.att.stored": "stocké",
  "fields.ex1": "status:active",
  "fields.ex1.title": "où le champ d'état contient active",
  "fields.ex2": "title:(quick OR brown)",
  "fields.ex2.title": "où le champ de titre contient quick ou brown",
  "fields.ex3": "author:\"John Smith\"",
  "fields.ex3.title": "où le champ auteur contient la phrase exacte \"john smith\"",
  "fields.ex4": "book.\\*:(quick OR brown)",
  "fields.ex4.title": "où l'un des champs book.title, book.content ou book.date contient quick ou brown (notez comment nous devons échapper le * avec une barre oblique inverse):",
  "fields.ex5": "_exists_:title",
  "fields.ex5.title": "où le champ de titre a une valeur non nulle:",

  "fields.idx_hit": "Index des hits",
  "fields.idx_user": "Index des utilisateurs",
  "fields.idx_template": "Index des templates",
  "fields.idx_analytic": "Index des analytiques",
  "fields.idx_action": "Index des actions",
  "fields.idx_view": "Index des vues",

  "fields.important": "Important",
  "fields.important.text": "Lorsque vous utilisez le moteur de recherche dans l'interface utilisateur, votre requête de recherche est effectuée sur tous ces index en même temps, sauf si vous spécifiez explicitement l'index que vous souhaitez cibler.",
  "fields.legend": "Légende",
  "fields.legend.default": "Interrogé lorsqu'aucun champ n'est spécifié",
  "fields.legend.ip_field": "Peut être interrogé en utilisant la notation CIDR",
  "fields.legend.list": "Peut avoir plusieurs valeurs dans le même document",
  "fields.legend.stored": "Renvoyé par défault dans les résultats de recherche",
  "fields.legend.text": "Les particularités de certains types de champs ainsi que leurs différents attributs sont expliqués ici:",
  "fields.legend.text_field": "Seul les premiers 4k sont indexé, les recherches par caractères génériques ne fonctionneront pas comme prévu et ce champ ne peut pas être trié",
  "fields.table.attrib": "Attributs",
  "fields.table.description": "Description",
  "fields.table.name": "Nom du champ",
  "fields.table.type": "Type",
  "fields.text": "En utilisant la recherche de base, seul le champ par défaut est recherché pour les termes de recherche, mais il est possible de spécifier d'autres champs dans la syntaxe de la requête:",
  "fields.text2": "La banque de données Howler est divisée en plusieurs index. Chaque index dispose des champs suivants disponibles pour les recherches. Les champs par défaut sont copiés dans le champ de recherche par défaut qui est utilisé dans le cas où vous n'utilisez que la recherche de base. Les champs stocké seront renvoyé par l'index lors de l'émission d'une requête.",
  "fuzziness": "Recherche approximative",
  "fuzziness.ex": "quikc~ brwn~ foks~",
  "fuzziness.ex2": "quikc~1",
  "fuzziness.text": "Nous pouvons rechercher des termes similaires, mais pas exactement comme nos termes de recherche, en utilisant l'opérateur «d'approximation»:",
  "fuzziness.text2": "Cela utilise la distance Damerau-Levenshtein pour trouver tous les termes avec un maximum de deux changements, où un changement est l'insertion, la suppression ou la substitution d'un seul caractère, ou la transposition de deux caractères adjacents.",
  "fuzziness.text3": "La distance d'édition par défaut est de 2, mais une distance d'édition de 1 devrait être suffisante pour attraper 80% de toutes les fautes d'orthographe humaines. Elle peut être spécifié comme:",
  "grouping": "Regroupement",
  "grouping.ex": "(quick OR brown) AND fox",
  "grouping.ex2": "status:(active OR pending) title:(+full -\"text search\")",
  "grouping.text": "Plusieurs termes ou clauses peuvent être regroupés avec des parenthèses, pour former des sous-requêtes:",
  "grouping.text2": "Les groupes peuvent également être utilisés pour cibler un champ particulier:",
  "operator": "Opérateurs booléens",
  "operator.ex1": "quick brown +fox -news",
  "operator.ex2": "((quick AND fox) OR (brown AND fox) OR fox) AND NOT news",
  "operator.list1": "fox doit être présent",
  "operator.list2": "news doit être absent",
  "operator.list3": "quick and brown sont facultatifs - leur présence augmente la pertinence",
  "operator.text": "Par défaut, tous les termes sont facultatifs, en autant qu'un terme correspond. Une recherche de foo bar baz trouvera tout document contenant un ou plusieurs des éléments foo, bar ou baz. Nous avons déjà discuté de l'operateur par défault ci-dessus qui vous permet de forcer tous les termes à être requis, mais il existe également des opérateurs booléens qui peuvent être utilisés dans la requête de recherche elle-même pour fournir plus de contrôle.",
  "operator.text2": "The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query:",
  "operator.text3": "stipule que:",
  "operator.text4": "Les opérateurs booléens familiers AND, OR et NOT (également écrits &&, || et!) Sont également pris en charge, mais sachez qu'ils ne respectent pas les règles de précédence habituelles, donc les parenthèses doivent être utilisées chaque fois que plusieurs opérateurs sont utilisés ensemble. Par exemple, la requête précédente pourrait être réécrite comme:",
  "operator.text5": "Cette requête reproduit désormais correctement la logique de la requête d'origine, mais le score de pertinence ne ressemble guère à l'original.",
  "overview": "Aperçu",
  "overview.text": "Le «mini-langage» de la requête de recherche est utilisé par l'API de recherche. Les opérateurs vous permettent de personnaliser la recherche - les options disponibles sont expliquées ci-dessous:",
  "proximity": "Recherches de proximité",
  "proximity.ex": "\"quick fox\"~5",
  "proximity.text": "Alors qu'une requête de phrase (par exemple \"john smith\") attend tous les termes exactement dans le même ordre, une requête de proximité permet aux mots spécifiés d'être plus éloignés ou dans un ordre différent. De la même manière que les requêtes approximatives peuvent spécifier une distance d'édition maximale pour les caractères d'un mot, une recherche de proximité nous permet de spécifier une distance d'édition maximale des mots dans une phrase:",
  "proximity.text2": "Plus le texte d'un champ est proche de l'ordre d'origine spécifié dans la requête de recherche, plus ce document est considéré comme pertinent. Par rapport à l'exemple de requête ci-dessus, l'expression «quick fox» serait considérée comme plus pertinente que «quick brown fox».",
  "ranges": "Portées",
  "ranges.datemath": "Syntaxe de DateMath",
  "ranges.datemath.ex1": "y => Années\nM => Mois\nw => Semaines\nd => Jours\nh => Heures\nH => Heures\nm => Minutes\ns => Secondes",
  "ranges.datemath.ex2": "now+1h             =>  maintenant en millisecondes plus une heure. Devient: 2001-01-01 13:00:00\nnow-1h             =>  maintenant en millisecondes moins une heure. Devient: 2001-01-01 11:00:00\nnow-1h/d           =>  maintenant en millisecondes moins une heure, arrondi par jour. Devient: 2001-01-01 00:00:00\n2001.02.01||+1M/d  =>  2001-02-01 en millisecondes plus un mois arrondi par jour. Devient: 2001-03-01 00:00:00",
  "ranges.datemath.list1": "+ 1h: Ajouter une heure",
  "ranges.datemath.list2": "-1d: soustrait un jour",
  "ranges.datemath.list3": "/d: Arrondit au jour le plus proche",
  "ranges.datemath.text": "L'expression commence par une date d'ancrage, qui peut être now, ou une date se terminant par ||. Cette date d'ancrage peut éventuellement être suivie d'une ou plusieurs expressions mathématiques:",
  "ranges.datemath.text2": "Les unités de temps prises en charge diffèrent de celles prises en charge par les unités de temps pour les durées. Les unités prises en charge sont:",
  "ranges.datemath.text3": "En supposant que le temps présent soit 2001-01-01 12:00:00, voici quelques exemples:",
  "ranges.ex1": "date:[2012-01-01 TO 2012-12-31]",
  "ranges.ex1.title": "Tous les jours en 2012:",
  "ranges.ex10": "age:(>=10 AND <20)\nage:(+>=10 +<20)",
  "ranges.ex2": "date:[now/y TO now/y+1y]",
  "ranges.ex2.title": "Tout cette année: (Utilisation de la syntaxe DateMath)",
  "ranges.ex3": "date:[2012-06-08||/y TO now]",
  "ranges.ex3.title": "Tout depuis l'année de la date spécifique: (Utilisation de la syntaxe DateMath)",
  "ranges.ex4": "count:[1 TO 5]",
  "ranges.ex4.title": "Nombres 1..5",
  "ranges.ex5": "tag:{alpha TO omega}",
  "ranges.ex5.title": "Tags entre alpha et oméga, à l'exclusion de l'alpha et de l'oméga:",
  "ranges.ex6": "count:[10 TO *]",
  "ranges.ex6.title": "Numéros à partir de 10",
  "ranges.ex7": "date:{* TO 2012-01-01}",
  "ranges.ex7.title": "Dates antérieures à 2012",
  "ranges.ex8": "count:[1 TO 5}",
  "ranges.ex8.title": "Numéros de 1 à 5, n'incluant pas 5",
  "ranges.ex9": "age:>10\nage:>=10\nage:<10\nage:<=10",
  "ranges.text": "Les portées peuvent être spécifiées pour les champs de date, numériques ou de chaîne. Les portées inclusives sont spécifiées avec des crochets [min TO max] et des portées exclusives avec des accolades {min TO max}.",
  "ranges.text2": "Les accolades et les crochets peuvent être combinés:",
  "ranges.text3": "Les portées avec un côté illimité peuvent utiliser la syntaxe suivante:",
  "ranges.text4": "Pour combiner une limite supérieure et inférieure avec la syntaxe simplifiée, vous devez joindre deux clauses avec un opérateur AND:",
  "regex": "Expressions régulières",
  "regex.alternation": "Alternance",
  "regex.alternation.ex": "aabb|bbaa   # correspondra\naacc|bb     # ne correspondra pas\naa(cc|bb)   # correspondra\na+|b+       # ne correspondra pas\na+b+|b+a+   # correspondra\na+(b|c)+    # correspondra",
  "regex.alternation.text": "Le symbole de tube \"|\" agit comme un opérateur OR. Le match réussira si le motif du côté gauche ou du côté droit correspond. L'alternance s'applique au motif le plus long, pas au plus court. Pour la chaîne \"aabb\":",
  "regex.anchoring": "Ancrage",
  "regex.anchoring.ex": "ab.*     # correspondra\nabcd     # ne correspondra pas",
  "regex.anchoring.text": "La plupart des moteurs d'expressions régulières vous permettent de faire correspondre n'importe quelle partie d'une chaîne. Si vous voulez que le modèle d'expression régulière commence au début de la chaîne ou se termine à la fin de la chaîne, vous devez l'ancrer spécifiquement, en utilisant ^ pour indiquer le début ou $ pour indiquer la fin.",
  "regex.anchoring.text2": "Les expressions régulières de Lucene sont toujours ancrées. Le modèle fourni doit correspondre à la chaîne entière. Pour la chaîne \"abcde\":",
  "regex.any": "Correspondre à n'importe quel",
  "regex.any.ex": "ab...   # correspondra\na.c.e   # correspondra",
  "regex.any.text": "Le point \".\" Peut être utilisé pour représenter n'importe quel caractère. Pour la chaîne \"abcde\":",
  "regex.chars": "Caractères autorisés",
  "regex.chars.ex": ". ? + * | { } [ ] ( ) \" \\",
  "regex.chars.ex2": "john\"@smith.com\"",
  "regex.chars.text": "Tous les caractères Unicode peuvent être utilisés dans le modèle, mais certains caractères sont réservés et doivent être échappés. Les caractères réservés standard sont:",
  "regex.chars.text2": "Tout caractère réservé peut être échappé par une barre oblique inverse \"\\*\" comprenant une barre oblique inverse littérale: \"\\\\\"",
  "regex.chars.text3": "De plus, tous les caractères (à l'exception des guillemets doubles) sont interprétés littéralement lorsqu'ils sont entourés de guillemets doubles:",
  "regex.class": "Classe de caractères",
  "regex.class.ex": "[abc]   # 'a' ou 'b' ou 'c'\n[a-c]   # 'a' ou 'b' ou 'c'\n[-abc]  # '-' ou 'a' ou 'b' ou 'c'\n[abc\\-] # '-' ou 'a' ou 'b' ou 'c'\n[^abc]  # tout caractère sauf 'a' ou 'b' ou 'c'\n[^a-c]  # tout caractère sauf 'a' ou 'b' ou 'c'\n[^-abc]  # tout caractère sauf '-' ou 'a' ou 'b' ou 'c'\n[^abc\\-] # tout caractère sauf '-' or 'a' ou 'b' ou 'c'",
  "regex.class.ex2": "ab[cd]+     # correspondra\n[a-d]+      # correspondra\n[^a-d]+     # ne correspondra pas",
  "regex.class.text": "Les plages de caractères potentiels peuvent être représentées sous forme de classes de caractères en les mettant entre crochets \"[]\". Un ^ en tête annule la classe de caractères. Les formes autorisés sont:",
  "regex.class.text2": "Notez que le tiret \"-\" indique une plage de caractères, sauf s'il s'agit du premier caractère ou s'il est échappé par une barre oblique inverse.",
  "regex.class.text3": "For la chaîne \"abcd\":",
  "regex.ex": "name:/joh?n(ath[oa]n)/",
  "regex.grouping": "Regroupement",
  "regex.grouping.ex": "(ab)+       # correspondra\nab(ab)+     # correspondra\n(..)+       # correspondra\n(...)+      # ne correspondra pas\n(ab)*       # correspondra\nabab(ab)?   # correspondra\nab(ab)?     # ne correspondra pas\n(ab){3}     # correspondra\n(ab){1,2}   # ne correspondra pas",
  "regex.grouping.text": "Les parenthèses \"()\" peuvent être utilisées pour former des sous-motifs. Les opérateurs de quantité énumérés ci-dessus fonctionnent sur le modèle précédent le plus court, qui peut être un groupe. Pour la chaîne \"ababab\":",
  "regex.minmax": "Min à Max",
  "regex.minmax.ex": "{5}     # répéter exactement 5 fois\n{2,5}   # répéter au moins deux fois et au plus 5 fois\n{2,}    # répéter au moins deux fois",
  "regex.minmax.ex2": "a{3}b{3}        # correspondra\na{2,4}b{2,4}    # correspondra\na{2,}b{2,}      # correspondra\n.{3}.{3}        # correspondra\na{4}b{4}        # ne correspondra pas\na{4,6}b{4,6}    # ne correspondra pas\na{4,}b{4,}      # ne correspondra pas",
  "regex.minmax.text": "Les accolades \"{}\" peuvent être utilisées pour spécifier un nombre minimum et (facultatif) un nombre maximum de fois que le motif le plus court précédent peut se répéter. Les formes autorisés sont:",
  "regex.minmax.text2": "Pour la chaîne \"aaabbb\":",
  "regex.oneplus": "Un ou plus",
  "regex.oneplus.ex": "a+b+        # correspondra\naa+bb+      # correspondra\na+.+        # correspondra\naa+bbb+     # correspondra",
  "regex.oneplus.text": "Le signe plus \"+\" peut être utilisé pour répéter une ou plusieurs fois le motif le plus court précédent. Pour la chaîne \"aaabbb\":",
  "regex.text": "Les modèles d'expression régulière peuvent être incorporés dans la requête de recherche en les encapsulant dans des barres obliques (\"/\"):",
  "regex.warning": "Avertissement",
  "regex.warning.ex": "/.*n/",
  "regex.warning.follow": "La syntaxe d'expression régulière prise en charge est la suivante:",
  "regex.warning.text": "Avoir un caractère générique comme paramètre principal n'a aucun contrôle sur les expressions régulières. Une requête de recherche telle que la suivante forcerait la banque de données à visiter tous les termes de l'index, à utiliser avec précaution!:",
  "regex.zeroone": "Zéro ou un",
  "regex.zeroone.ex": "aaa?bbb?    # correspondra\naaaa?bbbb?  # correspondra\n.....?.?    # correspondra\naa?bb?      # ne correspondra pas",
  "regex.zeroone.text": "Le point d'interrogation \"?\" rend le modèle le plus court précédent facultatif. Il correspond à zéro ou une fois. Pour la chaîne \"aaabbb\":",
  "regex.zeroplus": "Zéro ou plus",
  "regex.zeroplus.ex": "a*b*        # correspondra\na*b*c*      # correspondra\n.*bbb.*     # correspondra\naaa*bbb*    # correspondra",
  "regex.zeroplus.text": "L'astérisque \"*\" peut être utilisé pour faire correspondre zéro ou plusieurs fois le modèle le plus court précédent. Pour la chaîne \"aaabbb\":",
  "reserved": "Caractères réservés",
  "reserved.ex": "\\(1\\+1\\)\\=2",
  "reserved.ex2": "+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /",
  "reserved.note": "Noter",
  "reserved.text": "Si vous avez besoin d'utiliser l'un des caractères qui fonctionnent comme des opérateurs dans votre requête elle-même (et non comme des opérateurs), vous devez alors les échapper avec une barre oblique inverse.",
  "reserved.text2": "Par exemple, pour rechercher (1+1)=2, vous devez écrire votre requête sous la forme:",
  "reserved.text3": "Les caractères réservés sont:",
  "reserved.text4": "Ne pas échapper correctement à ces caractères spéciaux peut entraîner une erreur de syntaxe qui empêche l'exécution de votre requête.",
  "reserved.text5": "< et > ne peuvent pas être échappés. Le seul moyen de les empêcher de tenter de créer une requête de plage est de les supprimer entièrement de la requête de recherche.",
  "subtitle": "Syntaxe de requêtes Lucene et liste des champs d'index",
  "title": "Aide à la Recherche",
  "toc": "Sommaire",
  "top": "Retour au début",
  "wildcard": "Caractères génériques",
  "wildcard.ex": "qu?ck bro*",
  "wildcard.note": "Noter",
  "wildcard.note.text": "Autoriser un caractère générique au début d'un mot (par exemple \"* ing\") est particulièrement lourd, car tous les termes de l'index doivent être examinés, juste au cas où ils correspondent.",
  "wildcard.text": "Les recherches génériques peuvent être exécutées sur des termes individuels, en utilisant ? pour remplacer un seul caractère, et * pour remplacer zéro ou plusieurs caractères:",
  "wildcard.text2": "Sachez que les requêtes génériques peuvent utiliser une énorme quantité de mémoire et sont lentes - pensez simplement au nombre de termes qui doivent être interrogés pour correspondre à la requête de recherche \"a * b * c *\"."
}
